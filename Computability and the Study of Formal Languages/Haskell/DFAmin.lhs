-- DFA Minimization 
-- Kurt Medley 
-- April 2013
-------------------------------
A deterministic finite automaton (DFA) —also known as deterministic finite state machine— is a finite state machine that accepts/rejects finite strings of symbols and only produces a unique computation (or run) of the automaton for each input string. 
--Hopcroft, John E.; Motwani, Rajeev; Ullman, Jeffrey D. (2001). Introduction to Automata Theory, Languages, and Computation (2 ed.). Addison Wesley. ISBN 0-201-44124-1.
-------------------------------
This program presents a schema for the state diagram generated by the provided DFA-M.
Let DFA M = (Q,E,D,q0,F) where 
	Q  = {States}, 
	E  = {Alphabet}, 
	D  = {Delta Transitions}
	q0 = Start State
	F  = Final State
-------------------------------
A DFA-M can be inferred by a list of transitions given by the quintuple ((x1,x2,x3,x4,x5)).
 x1 - Current state <Q> 0 yes, 1 no
 x2 - Start state? <q0>
 x3 - Is this a final state? <F> 0 yes, 1 no
 x4 - Input symbol <E>
 x5 - End in state <Q>
-------------------------------

> import Data.List (nub, subsequences)
> type Transition = (String, Int, Int, String, String)

> example :: Transition
> example = ("A",0,1,"a","B")
> -- Start state; Beginning state A, processing input symbol a, end in state B; Not a final state.

> type DFA = [Transition]

Example state diagram processing the string aba. 
   ---            ---	         ---		---
 >| A | -- a --> | B | -- b --> | C | -- a --> | D |
   ---		  ---	         ---		---F

> dfa1 :: DFA
> dfa1 = [ ("A",0,1,"a","B"),
>	   ("B",1,1,"b","C"),
>	   ("C",1,1,"a","D"),
>	   ("D",1,0,"lam","D") ]

> dfa2 :: DFA
> dfa2 = [ ("A",0,1,"a","B"),("A",0,1,"b","D"),
>	   ("B",1,0,"a","C"),("B",1,0,"b","E"),
>	   ("C",1,1,"a","F"),("C",1,1,"b","F"),
>	   ("D",1,0,"a","E"),("D",1,0,"b","C"),
>	   ("E",1,1,"a","F"),("E",1,1,"b","F"),
>	   ("F",1,0,"a","G"),("F",1,0,"b","F"),
>	   ("G",1,0,"a","G"),("G",1,0,"b","G") ]

* lam = lambda, or the empty string.  These will only be present in final states.

Here we can infer the specifics of the given DFA-M by the transition table..
Qi: { A,B,C,D }
E: { a,b }
q0:{ A }
F: { D }
------------------------------

> main = do
>	putStrLn $ "\n" ++ show (dfa2) ++ "\n"
>	putStrLn $ "\n" ++ "Original DFA: " ++ "\n"
>	showDFA dfa2
>	putStrLn $ "\n" ++ "New DFA: " ++ "\n"
>	newDFA dfa2

------------------------------

The first step in DFA minimization is generating a distinguishable list.  A 'distinguish list' compares every pair of states.  A pair is distinguishable iff one state is final, and the other is not.  Example (A,D),(B,D),(C,D) are distinguishable states whereas (A,B),(B,C),(D,D) are not disguishable.. yet.  So, the first step is finding the states of the DFA-M.  Constructing a series of 'lookup' functions that will associate states with their desired traits..

> -- DFA boolean tests
> isStart :: String -> DFA -> Bool
> isStart state ((a,b,c,d,e):xs)
>	| (state == a) && (b == 0)	= True
>	| otherwise			= isStart state xs
> isStart state [] 			= False

> isFinal :: String -> DFA -> Bool
> isFinal state ((a,b,c,d,e):xs)
>	| (state == a) && (c == 0)	= True
>	| otherwise			= isFinal state xs
> isFinal state []			= False

> -- DFA characteristical lookup functions
> states :: DFA -> [String]
> states [] = []
> states ((a,b,c,d,e):xs) = nub $ a:e:states xs

> startState :: DFA -> [String]
> startState [] = []
> startState ((a,b,c,d,e):xs)
>	| b == 0	= nub $ a : startState xs
>	| otherwise	= startState xs

> finalStates :: DFA -> [String]
> finalStates [] = []
> finalStates ((a,b,c,d,e):xs)
>	| c == 0	= nub $ a : finalStates xs
>	| otherwise	= finalStates xs

> alphabet :: DFA -> [String]
> alphabet [] = []
> alphabet ((a,b,c,d,e):xs) = nub $ d : alphabet xs

> -- Transition to: Gives the ending state of a state and its input
> transTo :: String -> String -> DFA -> String
> transTo start sym ((a,b,c,d,e):xs)
>	| start == a && sym == d	= e
>	| otherwise			= transTo start sym xs
> transTo start sym [] = error "Input symbol does not exist."
 
> showDFA dfa = do
> 	putStrLn $ 	"States: " ++ show (states dfa) ++ "\n" ++
>			"Start State: " ++ show (startState dfa) ++ "\n" ++
>			"Final States: " ++ show (finalStates dfa) ++ "\n" ++
>			"Alphabet: " ++ show (alphabet dfa)
> --------------------------------

And now, creating the subsequences of states to create a "distinguish list".

> -- Create a list of states as tuples
> pairs [] = []
> pairs dfa = [ (x,y) | [x,y] <- subsequences $ states dfa ]

> -- Distinguishable given pair of states, 1 is final, 1 is not
> isDist (x,y) dfa 
>	| (isFinal x dfa) && (not $ isFinal y dfa) ||
>	  (isFinal y dfa) && (not $ isFinal x dfa)	= True
>	| otherwise 					= False

> -- Propegate a list of distinguishable pairs
> distinguishList dfa = [ (x,y) | (x,y) <- pairs dfa, isDist (x,y) dfa ]

Create a dependancy list from pairs that aren't distinguishable

> nonDistinguished dfa = [ (x,y) | (x,y) <- pairs dfa, not $ isDist (x,y) dfa ]

> -- Input symbol list, nondistinguished list, dfa 
> dependancyList1 dfa = [ ((transTo x z dfa),(transTo y z dfa)) |
>			(x,y) <- nonDistinguished dfa, z <- alphabet dfa ]

> dependancyList2 dfa = [ ((transTo y z dfa), (transTo x z dfa)) |
>			(x,y) <- nonDistinguished dfa, z <- alphabet dfa ]

> -- finalDep combines all possible pairs of states that represent the dependancy list.
> finalDep dfa = (dependancyList1 dfa) ++ (dependancyList2 dfa)

We need a function that will take each element from the non-distinguished list and examine if its an element of the dependancy list.  If its true, add it to the distinguished list.

> -- if a pair's dependent pair is itself or a pair of matching states, the resulting pair is NOT distinguishable.

mark elements from the nondistinguished list whose dependency pairs are members of the distinguished list.

> mark [] dfa = []
> mark (depx:depxs) dfa
>	| depx `elem` distinguishList dfa 	= depx : mark depxs dfa
>	| otherwise				= mark depxs dfa

> itself (x,y) (a:as) dfa 
>	| 	((transTo x a dfa) == x && (transTo y a dfa) == y)
>		|| (transTo x a dfa) == (transTo y a dfa)	= True
>	| otherwise = itself (x,y) as dfa
> itself (x,y) [] dfa = False

mark elements from the nondistinguished list whose dependency pairs are members of the distinguished list

> congeal [] dependL dfa	 = []
> congeal (x:xs) dependL dfa
>	| x `elem` dependL && not (itself (fst x, snd x) (alphabet dfa) dfa) 
>				= x:(congeal xs (x:dependL) dfa)
>	| otherwise		= congeal xs dependL dfa

> test dfa = mark (distinguishList dfa) dfa ++ congeal (nonDistinguished dfa) (finalDep dfa) dfa

> comb dfa = congeal (test dfa) (finalDep dfa) dfa

> dependsOn x dfa = [ ((transTo (fst x) i dfa), (transTo (snd x) i dfa)) | i <- alphabet dfa ] 

> collapse (x:xs) ys
>	| x `elem` ys	= collapse xs ys
>	| otherwise 	= x : collapse xs ys
> collapse [] ys = [] 

> collapse1 dfa = [ (x,y) | i <- nonDistinguished dfa, (x,y) <- dependsOn i dfa, not (elem (x,y) (comb dfa)) && not (elem (x,y) (distinguishList dfa)) ]

> remD (x:xs) 
> 	| (fst x) == (snd x)	= remD xs
>	| otherwise		= x : remD xs
> remD [] = []

> remPairs [] = []
> remPairs (y:[]) = [y]
> remPairs (x:y:xs)
>	| (fst x == fst y) || (fst x == snd y) || (snd x == fst y) || (snd x == snd y)
>			= remPairs (y:xs)
>	| otherwise 	= x : remPairs (y:xs)

> collapse2 dfa = 
>	[ i | i <- nonDistinguished dfa, (x,y) <- dependsOn i dfa, elem (x,y) (remD $ collapse1 dfa) ]

> finalCollapse dfa = remPairs $ nub $ remD $ (collapse1 dfa) ++ (collapse2 dfa)

---------------------------------
finalCollapse produces the list of collapsable, undistinguished states.  What's left is all for aesthetic purposes.  Everything else about the dfa can be inferred deductively.  States (E,C), (F,G), and (B,D) are generated;  Each state within the pair has its deterministic transition to a different state.  For example, E is neither a start or final state, on an input, "a" or "b", the machine transitions to "F"; However, we observe that F is undistinguishable from G;  Now examining C, on inputs "a" and "b", the machine transitions to F.  So we say within states E or C, on inputs "a" and "b", the machine transitions to the state (F,G) -- (Remembering that F is undistinguishable from G).  Where is A?  A is a state by itself that transitions to the undistinguishable states B and D; this is another pairwise state (B,D). 
							  ------
 ---		-------		   -------	      -------	| a,b
| A | - a,b -> | (B,D) | - a,b -> | (E,C) | - a,b -> | (F,G) | <-
 ---		-------F	   -------	      -------F

Thus we observe that dfa2 is a FSM that accepts the regular language:
	a U b ( a U b ( a U b )+ )?
	ex strings accepted: a, b, aaa, aba, babababababa, aaababababa
---------------------------------

> newStates :: Eq a => [a] -> [(a,a)] -> [a]
> newStates (x:xs) tups
>	| elem x (flattenTup tups)	= newStates xs tups
>	| otherwise			= x : newStates xs tups
> newStates [] tups = []

> flattenTup :: [(a,a)] -> [a]
> flattenTup [] = []
> flattenTup (x:xs) = fst x : snd x : flattenTup xs

> newFinalStates (x:xs) dfa
>	| isFinal (fst x) dfa	= x : newFinalStates xs dfa
>	| otherwise		= newFinalStates xs dfa
> newFinalStates [] dfa = []

>-- newDFA :: DFA -> IO ()
> newDFA dfa = do
>	putStrLn $ "Undistinguishable State(s): " ++ show (finalCollapse dfa) ++ "\n" ++
>		   "Distinguishable State(s): " ++ show (newStates (states dfa) (finalCollapse dfa)) ++ "\n" ++ "Alphabet: " ++ show (alphabet dfa) ++ "\n" ++ "Final States: " ++ show (newFinalStates (finalCollapse dfa) dfa)
